name: Build / Openterface Windows portable

on:
  push:
    branches: ["main", "dev_1223_portable_build"]
    paths:
      - '.github/workflows/windows-portable-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
  pull_request:
    branches: ["dev"]
    paths:
      - '.github/workflows/windows-portable-build.yaml'
      - 'vcpkg.json'
      - 'CMakeLists.txt'
      - '**/*.bat'
      - '**/*.cpp'
      - '**/*.h'
  workflow_dispatch:

defaults:
  run:
    shell: bash

env:
  ARTIFACT: openterfaceQT.windows.amd64.portable.exe
  SOURCE_DIR: ${{ github.workspace }}
  QT_VERSION: 6.6.3
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  VCPKG_DIR: D:\vcpkg
  VCPKG_KEEP_BUILDTREES: 1
  EXTERNAL_MINGW: C:\mingw64
  VCPKG_MAX_CONCURRENCY: 1
  # MinGW toolchain controls - ensure major versions match between Ubuntu cross and Windows build
  MINGW_GCC_MAJOR: '11'
  MINGW_RELEASE: 'v11.2.0-rev3'
  MINGW_FILE: 'x86_64-11.2.0-release-posix-seh-rt_v9-rev3.7z'

jobs:
  build-ffmpeg-cross:
    name: Build FFmpeg (cross-compile on Ubuntu)
    runs-on: ubuntu-22.04
    container:
      image: docker.io/cristianadam/mingw-builds:11
      options: --user root
    env:
      CROSS_TRIPLE: x86_64-w64-mingw32
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache ffmpeg cross build
        id: cache-ffmpeg-cross
        uses: actions/cache@v3
        with:
          path: |
            ffmpeg-build-temp
            ffmpeg-install
          # include the mingw toolchain tag and expected gcc major in cache key so changes in toolchain invalidate cache
          key: ffmpeg-cross-${{ runner.os }}-${{ env.MINGW_RELEASE }}-gcc${{ env.MINGW_GCC_MAJOR }}-${{ hashFiles('build-script/**') }}-v1
          restore-keys: |
            ffmpeg-cross-
      - name: Install dependencies and verify cross toolchain (container)
        run: |
          apt-get update
          apt-get install -y git make build-essential pkg-config nasm yasm curl wget tar cmake p7zip-full || true

          # Verify cross compiler presence inside the container
          echo "Checking cross compiler in container (CROSS_TRIPLE=${CROSS_TRIPLE})"
          if command -v ${CROSS_TRIPLE}-gcc >/dev/null 2>&1; then
            ver=$(${CROSS_TRIPLE}-gcc -dumpversion 2>/dev/null || true)
            major=$(printf '%s' "$ver" | sed -E 's/^([0-9]+).*/\1/' || true)
            echo "Detected ${CROSS_TRIPLE}-gcc version: ${ver} (major: ${major})"
          else
            ver=''
            major=none
            echo "No ${CROSS_TRIPLE}-gcc found in container"
          fi

          # If the container already has GCC 11, use it and set CROSS_PREFIX
          if [ "${major}" = "${MINGW_GCC_MAJOR}" ]; then
            echo "Native GCC ${MINGW_GCC_MAJOR} cross-compiler available in container"
            echo "PATH=/usr/bin:$PATH" >> $GITHUB_ENV
            echo "CROSS_PREFIX=/usr/bin/${CROSS_TRIPLE}-" >> $GITHUB_ENV
            export CROSS_PREFIX=/usr/bin/${CROSS_TRIPLE}-
          else
            echo "Container does not contain ${MINGW_GCC_MAJOR}. Attempting to install or fall back to downloaded toolchain (download may contain Windows binaries and will not provide an ELF gcc)."
          fi
          if [ "${major}" != "${MINGW_GCC_MAJOR}" ]; then
            echo "Desired MinGW GCC major ${MINGW_GCC_MAJOR} not present. Attempting to install a native GCC ${MINGW_GCC_MAJOR} cross-compiler via apt"

            # Try adding the toolchain PPA to get newer gcc packages
            sudo apt-get update
            sudo apt-get install -y software-properties-common || true
            sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test || true
            sudo apt-get update || true

            # Try several package names that may provide a GCC ${MINGW_GCC_MAJOR} mingw cross-compiler
            echo "Attempting apt install of GCC ${MINGW_GCC_MAJOR} mingw packages"
            sudo apt-get install -y gcc-${MINGW_GCC_MAJOR}-mingw-w64 g++-${MINGW_GCC_MAJOR}-mingw-w64 mingw-w64 || true
            sudo apt-get install -y gcc-${MINGW_GCC_MAJOR} g++-${MINGW_GCC_MAJOR} || true

            # Verify whether the installation provided the desired major
            if command -v x86_64-w64-mingw32-gcc >/dev/null 2>&1; then
              ver=$(x86_64-w64-mingw32-gcc -dumpversion 2>/dev/null || true)
              major=$(printf '%s' "$ver" | sed -E 's/^([0-9]+).*/\1/' || true)
              echo "Post-install detected cross MinGW GCC version: ${ver} (major: ${major})"
            else
              ver=""
              major=none
              echo "Post-install: no x86_64-w64-mingw32-gcc found"
            fi

            if [ "${major}" = "${MINGW_GCC_MAJOR}" ]; then
              echo "Successfully installed native GCC ${MINGW_GCC_MAJOR} cross-compiler"
              echo "PATH=/usr/bin:$PATH" >> $GITHUB_ENV
              export PATH=/usr/bin:$PATH
              CROSS_PREFIX="/usr/bin/x86_64-w64-mingw32-"

            else
              echo "Failed to obtain native GCC ${MINGW_GCC_MAJOR} via apt; falling back to downloading a toolchain (but we will still require a native GCC ${MINGW_GCC_MAJOR} to be present later)."

              TMPDIR=/tmp/mingw-install
              mkdir -p "$TMPDIR"
              cd "$TMPDIR"
              curl -L -o mingw-w64.7z "https://github.com/cristianadam/mingw-builds/releases/download/${MINGW_RELEASE}/${MINGW_FILE}"
              7z x mingw-w64.7z
              # Move extracted files to /opt/mingw64 (replace if exists). Handle archives that don't create a single top-level directory.
              echo "Locating extracted directory..."
              shopt -s nullglob
              candidates=(x86_64-* mingw* *)
              shopt -u nullglob
              EXTRACT_DIR=""
              for d in "${candidates[@]}"; do
                if [ -d "$d" ]; then
                  # prefer directories containing a bin/ subdir
                  if [ -d "$d/bin" ]; then
                    EXTRACT_DIR="$d"
                    break
                  fi
                  # otherwise take the first directory found
                  EXTRACT_DIR="$d"
                  break
                fi
              done
              if [ -z "$EXTRACT_DIR" ]; then
                echo "No top-level directory found; moving all extracted content into /opt/mingw64"
                sudo rm -rf /opt/mingw64 || true
                sudo mkdir -p /opt/mingw64
                sudo mv ./* /opt/mingw64 || true
              else
                echo "Found extracted directory: $EXTRACT_DIR"
                sudo rm -rf /opt/mingw64 || true
                sudo mkdir -p /opt/mingw64
                # move contents of EXTRACT_DIR into /opt/mingw64 so /opt/mingw64/bin exists
                if sudo mv "$EXTRACT_DIR"/* /opt/mingw64/ 2>/dev/null; then
                  echo "Moved contents of $EXTRACT_DIR into /opt/mingw64"
                  sudo rm -rf "$EXTRACT_DIR" || true
                else
                  echo "mv failed, falling back to copy"
                  sudo cp -a "$EXTRACT_DIR"/. /opt/mingw64/ || true
                  sudo rm -rf "$EXTRACT_DIR" || true
                fi
              fi
              echo "Contents of /opt/mingw64:" || true
              sudo ls -la /opt/mingw64 || true

              # Try to find a native ELF x86_64-w64-mingw32-gcc in the extracted tree that matches the required major.
              FOUND_NATIVE=""
              for cand in /opt/mingw64/bin/x86_64-w64-mingw32-gcc*; do
                if [ -f "$cand" ]; then
                  echo "Inspecting $cand"
                  file_out=$(file -b "$cand" || true)
                  echo "$cand file: $file_out"
                  if echo "$file_out" | grep -qi 'elf'; then
                    ver=$("$cand" -dumpversion 2>/dev/null || true)
                    major=$(printf '%s' "$ver" | sed -E 's/^([0-9]+).*/\1/' || true)
                    echo "$cand reports version $ver (major $major)"
                    if [ "$major" = "${MINGW_GCC_MAJOR}" ]; then
                      FOUND_NATIVE="$cand"
                      break
                    fi
                  fi
                fi
              done

              if [ -n "$FOUND_NATIVE" ]; then
                echo "Found suitable native cross compiler: $FOUND_NATIVE"
                echo "PATH=/opt/mingw64/bin:$PATH" >> $GITHUB_ENV
                export PATH=/opt/mingw64/bin:$PATH
                CROSS_PREFIX="/opt/mingw64/bin/x86_64-w64-mingw32-"
                # Create convenience symlinks for found native tools
                sudo mkdir -p /usr/local/bin
                for prog in x86_64-w64-mingw32-gcc x86_64-w64-mingw32-g++ x86_64-w64-mingw32-ar x86_64-w64-mingw32-gcc-ar x86_64-w64-mingw32-gcc-nm x86_64-w64-mingw32-gcc-ranlib; do
                  if [ -x "/opt/mingw64/bin/$prog" ]; then
                    sudo ln -sf "/opt/mingw64/bin/$prog" /usr/local/bin/$prog || true
                  fi
                done
              else
                echo "ERROR: Could not obtain a native GCC ${MINGW_GCC_MAJOR} cross-compiler (apt and download attempts failed)."
                echo "Please provide a runner image with x86_64-w64-mingw32-gcc version ${MINGW_GCC_MAJOR}, or point to a reliable prebuilt native toolchain tarball that contains an ELF x86_64-w64-mingw32-gcc-11 binary."
                exit 1
              fi

            fi

            # Debug: show which compiler will be used and its reported version
            echo "Which x86_64-w64-mingw32-gcc: $(command -v x86_64-w64-mingw32-gcc || true)"
            x86_64-w64-mingw32-gcc -dumpversion || true
            x86_64-w64-mingw32-gcc -v 2>&1 || true
            echo "Listing toolchain bin folder if present:" ; ls -la /opt/mingw64/bin || true
            echo "CROSS_PREFIX=${CROSS_PREFIX}" >> $GITHUB_ENV
            export CROSS_PREFIX=${CROSS_PREFIX}
            cd -
            rm -rf "$TMPDIR"
          else
            echo "Using system mingw-w64 with GCC ${ver}"
          fi
      - name: Verify cross MinGW GCC major version matches expected
        run: |
          set -e
          # Debug: show which compiler is currently on PATH and details
          echo "Debug: which x86_64-w64-mingw32-gcc: $(command -v x86_64-w64-mingw32-gcc || true)"
          x86_64-w64-mingw32-gcc -dumpversion || true
          x86_64-w64-mingw32-gcc -v 2>&1 || true
          echo "Contents of /opt/mingw64/bin:" ; ls -la /opt/mingw64/bin || true
          if ! command -v x86_64-w64-mingw32-gcc >/dev/null 2>&1; then
            echo "ERROR: x86_64-w64-mingw32-gcc not found after installing mingw-w64"
            exit 1
          fi
          # Prefer the installed toolchain under /opt/mingw64 if present
          if [ -x /opt/mingw64/bin/x86_64-w64-mingw32-gcc ]; then
            ver=$(/opt/mingw64/bin/x86_64-w64-mingw32-gcc -dumpversion 2>/dev/null || true)
            echo "Using /opt/mingw64 compiler: /opt/mingw64/bin/x86_64-w64-mingw32-gcc"
          elif command -v x86_64-w64-mingw32-gcc >/dev/null 2>&1; then
            ver=$(x86_64-w64-mingw32-gcc -dumpversion 2>/dev/null || true)
            echo "Using system compiler: $(command -v x86_64-w64-mingw32-gcc)"
          else
            ver=
            echo "No x86_64-w64-mingw32-gcc found"
          fi
          major=$(printf '%s' "$ver" | sed -E 's/^([0-9]+).*/\1/') || true
          echo "Found cross MinGW GCC version: ${ver} (major: ${major})"
          if [ "${major}" != "${MINGW_GCC_MAJOR}" ]; then
            echo "ERROR: cross MinGW GCC major ${major} does not match expected ${MINGW_GCC_MAJOR}" >&2
            exit 1
          fi
          echo "Cross MinGW GCC major matches expected ${MINGW_GCC_MAJOR}"
      - name: Run cross build script
        env:
          PREFIX: /tmp/ffmpeg-static-windows
          CROSS_PREFIX: x86_64-w64-mingw32-
        run: |
          mkdir -p $PREFIX
          cd build-script
          bash build-static-ffmpeg-cross.sh
      - name: Archive ffmpeg artifact
        run: |
          cd /tmp
          tar -czf ffmpeg-static-windows.tar.gz -C /tmp ffmpeg-static-windows
      - name: Upload ffmpeg artifact
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-static-windows
          path: /tmp/ffmpeg-static-windows.tar.gz

  build:
    needs: build-ffmpeg-cross
    runs-on: windows-2022
    defaults:
      run:
        shell: cmd
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache Qt Build
        id: cache-qt
        uses: actions/cache@v3
        with:
          path: C:\Qt6
          key: qt-6.6.3-mingw-windows-static-vcpkg
          restore-keys: |
            qt-6.6.3-mingw-windows-static-
      - name: Cache MinGW, Ninja and assembly packages
        id: cache-mingw
        uses: actions/cache@v3
        with:
          path: |
            C:\mingw64
            # cache common Chocolatey libraries and bin so binary tools like ninja, nasm, yasm are preserved across runs
            C:\ProgramData\chocolatey\lib\ninja
            C:\ProgramData\chocolatey\lib\nasm
            C:\ProgramData\chocolatey\lib\yasm
            C:\ProgramData\chocolatey\bin
          # keep a stable cache key so restorations can hit for typical runner snapshots
          key: mingw-ninja-nasm-yasm-static-11.2.0-rev3
          restore-keys: |
            mingw-ninja-nasm-yasm-static-
      - name: Cache external MinGW and related artifacts
        id: cache-mingw-external
        uses: actions/cache@v3
        with:
          path: |
            C:\mingw64
            C:\mingw64\bin
            D:\vcpkg\downloads\tools
          key: mingw-${{ runner.os }}-mingw64-${{ hashFiles('vcpkg.json') }}-v1
          restore-keys: |
            mingw-${{ runner.os }}-mingw64-
      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v3
        with:
          path: D:\vcpkg
          key: vcpkg-x64-mingw-static-openssl-ffmpeg-zlib-v1
          restore-keys: |
            vcpkg-x64-mingw-static-
              
      - name: Cache FFmpeg Build
        id: cache-ffmpeg
        uses: actions/cache@v3
        with:
          # FFmpeg installation may end up inside the repo's vcpkg (D:\vcpkg\installed) or
          # the standalone static build script installs to C:\ffmpeg-static (seen in logs).
          # Cache both locations so restore can hit regardless of which target was used.
          path: |
            D:\vcpkg\installed\x64-mingw-static\lib
            C:\ffmpeg-static\lib
          # Use the build scripts as part of the cache key so changes in scripts invalidate the cache
          key: ffmpeg-static-${{ runner.os }}-${{ hashFiles('build-script/build-static-ffmpeg-windows.bat', 'build-script/build-static-ffmpeg-windows.sh', 'build-script/build-static-ffmpeg-cross.sh') }}-v1
          restore-keys: |
            ffmpeg-static-
      - name: Cache vcpkg binary archives & downloads
        id: cache-vcpkg-archives
        uses: actions/cache@v3
        with:
          path: |
            C:\Users\runneradmin\AppData\Local\vcpkg\archives
            D:\vcpkg\downloads
          key: vcpkg-archives-${{ runner.os }}-${{ hashFiles('vcpkg.json') }}-v1
          restore-keys: |
            vcpkg-archives-${{ runner.os }}-
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Ninja and MinGW (if not cached)
        if: steps.cache-mingw.outputs.cache-hit != 'true'
        run: |
          echo Installing Ninja...
          choco install ninja -y
          echo Downloading MinGW-w64 static build (from ${MINGW_RELEASE})...
          curl -L -o mingw-w64.zip https://github.com/cristianadam/mingw-builds/releases/download/${{ env.MINGW_RELEASE }}/${{ env.MINGW_FILE }}
          mkdir C:\mingw64_tmp
          7z x mingw-w64.zip -oC:\mingw64_tmp
          move C:\mingw64_tmp\x86_64-11.2.0-release-posix-seh-rt_v9-rev3\* C:\mingw64\
          rmdir /s /q C:\mingw64_tmp
          echo Verifying g++...
          set PATH=C:\mingw64\bin;%PATH%
          g++ --version
      - name: Ensure ninja and assembler tools available (cache may restore files but ensure shims exist)
        run: |
          echo "Checking for ninja executable..."
          where ninja || (
            echo "ninja not found on PATH, installing via choco"
            choco install ninja -y
          )
          echo "Checking for nasm executable..."
          where nasm || (
            echo "nasm not found on PATH, installing via choco"
            choco install nasm -y || echo "nasm install failed"
          )
          echo "Checking for yasm executable..."
          where yasm || (
            echo "yasm not found on PATH, installing via choco"
            choco install yasm -y || echo "yasm install failed"
          )
      # We no longer use packaged MSYS-style toolchains in CI; prefer the external MinGW packaged in the workflow (C:\mingw64)
      - name: Ensure external MinGW on PATH
        run: |
          echo "Adding external MinGW to PATH"
          set PATH=C:\mingw64\bin;%PATH%
          g++ --version
          where g++
          echo "If g++ is not present, ensure the runner snapshot contains a working MinGW distribution at C:\mingw64"
      - name: Verify MinGW GCC major version matches expected
        shell: cmd
        run: |
          for /f "delims=" %%a in ('g++ -dumpversion') do set "GCC_VER=%%a"
          for /f "tokens=1 delims=." %%m in ("%GCC_VER%") do set "GCC_MAJOR=%%m"
          echo Found MinGW GCC version: %GCC_VER% (major: %GCC_MAJOR%)
          if not "%GCC_MAJOR%"=="%MINGW_GCC_MAJOR%" (
            echo ERROR: MinGW GCC major version %GCC_MAJOR% does not match expected %MINGW_GCC_MAJOR%.
            exit /b 1
          ) else (
            echo MinGW GCC major matches expected %MINGW_GCC_MAJOR%.
          )

      - name: Verify MinGW Static Linking Capability
        run: |
          set PATH=C:\mingw64\bin;%PATH%
          echo "Testing static compilation with MinGW..."
          echo #include ^<iostream^> > test.cpp
          echo int main() { std::cout ^<^< "Static build OK!" ^<^< std::endl; return 0; } >> test.cpp
          g++ -static -O2 -s -o test.exe test.cpp
          if errorlevel 1 (
            echo "❌ Failed to compile a static C++ program."
            exit /b 1
          )
          test.exe
          if errorlevel 1 (
            echo "❌ Compiled executable failed to run."
            exit /b 1
          )
          echo "✅ MinGW static linking verified successfully."
          del test.cpp test.exe
      - name: Install or Update vcpkg (bootstrap only)
        run: |
          echo Cloning or updating vcpkg...
          if not exist "%VCPKG_DIR%\vcpkg.exe" (
            echo "vcpkg.exe not found, cloning vcpkg repo..."
            git clone https://github.com/microsoft/vcpkg.git %VCPKG_DIR%
            cd %VCPKG_DIR%
            git fetch --all --tags || echo "git fetch failed"
            call bootstrap-vcpkg.bat
          ) else (
            echo "%VCPKG_DIR%\vcpkg.exe already exists, updating vcpkg repo"
            cd %VCPKG_DIR%
            git fetch --all --tags || echo "git fetch failed"
            if defined VCPKG_BASELINE (
              git checkout %VCPKG_BASELINE% || git checkout tags/%VCPKG_BASELINE% || echo "git checkout baseline failed"
            ) else (
              git reset --hard origin/HEAD || echo "git reset failed"
            )
            call bootstrap-vcpkg.bat
          )
          cd "%SOURCE_DIR%"
          set VCPKG_LOG_LEVEL=debug
          set VCPKG_DOWNLOADS_RETRIES=5
          set VCPKG_MAX_CONCURRENCY=%VCPKG_MAX_CONCURRENCY%
          echo vcpkg version/loglevel: && "%VCPKG_DIR%\vcpkg.exe" version || echo "could not show vcpkg version"
          call "%VCPKG_DIR%\vcpkg.exe" integrate install
          echo vcpkg installed ports (end) && "%VCPKG_DIR%\vcpkg.exe" list || echo "couldn't list vcpkg packages"

      - name: Install OpenSSL via vcpkg (central)
        shell: cmd
        run: |
          echo "Installing OpenSSL into central vcpkg"
          set V=%VCPKG_DIR%\vcpkg.exe
          set attempt=1
          set max_attempts=3
          :openssl_loop
          echo Attempt %attempt% of %max_attempts%
          "%V%" install --classic openssl --triplet=x64-mingw-static --clean-after-build --debug
          if errorlevel 1 (
            echo "openssl install failed on attempt %attempt%"
            set /a attempt+=1
            if %attempt% LEQ %max_attempts% (
              echo "Retrying after pause..."
              powershell -c "Start-Sleep -s %attempt%"
              goto :openssl_loop
            ) else (
              echo "openssl install failed after %max_attempts% attempts"
              exit /b 1
            )
          ) else (
            echo "openssl install succeeded"
          )

      - name: Ensure OpenSSL is available in central vcpkg
        shell: cmd
        run: |
          echo Checking central vcpkg for OpenSSL static libs and headers...
          if exist "%VCPKG_DIR%\installed\x64-mingw-static\lib\libcrypto.a" (
            echo OpenSSL already present in central vcpkg
          ) else if exist "%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib\libcrypto.a" (
            echo Copying repo-local OpenSSL into central vcpkg
            mkdir "%VCPKG_DIR%\installed\x64-mingw-static\lib" 2>nul || echo "lib dir exists"
            mkdir "%VCPKG_DIR%\installed\x64-mingw-static\include" 2>nul || echo "include dir exists"
            xcopy "%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib\*" "%VCPKG_DIR%\installed\x64-mingw-static\lib\" /Y /I /S
            xcopy "%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\include\*" "%VCPKG_DIR%\installed\x64-mingw-static\include\" /Y /I /S
          ) else (
            echo Installing OpenSSL into central vcpkg
            "%VCPKG_DIR%\vcpkg.exe" install openssl --triplet=x64-mingw-static --clean-after-build --recurse || ( echo "vcpkg install failed" & exit /b 1 )
          )
      - name: OpenSSL availability (consolidated)
        shell: cmd
        run: |
          echo OpenSSL availability check already performed in the consolidated step above; skipping duplicate checks
      - name: Verify vcpkg manifest installation and artifact directory
        shell: cmd
        run: |
          echo "=== Workspace vcpkg.json presence ==="
          if exist "%SOURCE_DIR%\vcpkg.json" (
            echo "vcpkg.json found at %SOURCE_DIR%\vcpkg.json"
            type "%SOURCE_DIR%\vcpkg.json"
          ) else (
            echo "ERROR: vcpkg.json not found at %SOURCE_DIR% -- the manifest install will do nothing"
            dir "%SOURCE_DIR%" || true
            exit /b 1
          )
          echo "=== vcpkg executable and installed list ==="
          if exist "%VCPKG_DIR%\vcpkg.exe" (
            call "%VCPKG_DIR%\vcpkg.exe" version || echo "vcpkg version command failed"
            call "%VCPKG_DIR%\vcpkg.exe" list || echo "vcpkg list failed"
          ) else (
            echo "WARNING: vcpkg.exe not found at %VCPKG_DIR%"
          )
          echo "=== Installed libraries folder check ==="
          echo "Checking possible installed locations ( repo-local vcpkg_installed or central vcpkg installed )"
          set REPO_LIB_DIR=%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib
          set CENTRAL_LIB_DIR=%VCPKG_DIR%\installed\x64-mingw-static\lib
          echo REPO_LIB_DIR=%REPO_LIB_DIR%
          echo CENTRAL_LIB_DIR=%CENTRAL_LIB_DIR%
          if exist "%REPO_LIB_DIR%" (
            echo Found repo-local installed libraries at %REPO_LIB_DIR%
            dir "%REPO_LIB_DIR%"
          ) else if exist "%CENTRAL_LIB_DIR%" (
            echo Found central installed libraries at %CENTRAL_LIB_DIR%
            dir "%CENTRAL_LIB_DIR%"
          ) else (
            echo ERROR: No installed libraries found in either %REPO_LIB_DIR% or %CENTRAL_LIB_DIR%
            echo "Hint: vcpkg install may have failed or installed to a different location. Inspect the vcpkg debug output above."
            exit /b 1
          )
      - name: Download FFmpeg artifact from Ubuntu build
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-static-windows
          path: ${{ runner.temp }}\ffmpeg-artifact
      - name: Extract FFmpeg into C:\ffmpeg-static
        shell: cmd
        run: |
          if not exist C:\ffmpeg-static mkdir C:\ffmpeg-static
          tar -xzf "%RUNNER_TEMP%\ffmpeg-artifact\ffmpeg-static-windows.tar.gz" -C C:\
      - name: Set FFMPEG_PREFIX for subsequent steps
        shell: cmd
        run: |
          set FFMPEG_PREFIX=C:\ffmpeg-static
          echo FFMPEG_PREFIX set to %FFMPEG_PREFIX%
          echo Listing C:\ffmpeg-static\lib and include
          dir C:\ffmpeg-static\lib || echo "lib folder not found"
          dir C:\ffmpeg-static\include || echo "include folder not found"
      - name: Verify vcpkg static libraries (with debug output)
        run: |
          set VCPKG_MAX_CONCURRENCY=%VCPKG_MAX_CONCURRENCY%
          set LIB_DIR=%VCPKG_DIR%\installed\x64-mingw-static\lib
          set REPO_LIB_DIR=%SOURCE_DIR%\vcpkg_installed\x64-mingw-static\lib
          echo === vcpkg list ===
          if exist "%VCPKG_DIR%\vcpkg.exe" (
            call "%VCPKG_DIR%\vcpkg.exe" list
          ) else (
            echo WARNING: vcpkg.exe not found in %VCPKG_DIR% - skipping vcpkg list
          )
          echo === vcpkg bootstrap/log/version info ===
          if exist "%VCPKG_DIR%\.git" (
            cd "%VCPKG_DIR%" && git rev-parse --short HEAD && git describe --tags --dirty || echo "git info unavailable"
          ) else (
            echo "No git info for vcpkg"
          )
          echo === Looking for installed libs in either central or repo-local paths ===
          echo CENTRAL: %LIB_DIR%
          echo REPO: %REPO_LIB_DIR%
          if exist "%LIB_DIR%" (
            echo Found central installed libs at %LIB_DIR%
            dir "%LIB_DIR%"
          ) else if exist "%REPO_LIB_DIR%" (
            echo Found repo-local installed libs at %REPO_LIB_DIR%
            dir "%REPO_LIB_DIR%"
          ) else (
            echo ERROR: Library folder not found in either %LIB_DIR% or %REPO_LIB_DIR% && exit /b 1
          )
          echo All static libraries present.
      - name: Dump ffmpeg buildtrees folder on failure
        if: failure()
        run: |
          echo Dumping full buildtrees directory for ffmpeg
          dir D:\vcpkg\buildtrees\ffmpeg /s
          echo Done dumping
      - name: Build Qt Statically (if not cached) - using external MinGW
        if: steps.cache-qt.outputs.cache-hit != 'true'
        run: |
          REM Pass SOURCE_DIR explicitly to the script to ensure the batch sees the repo root
          call build-script/build-static-qt-from-source.bat "%SOURCE_DIR%"
      - name: Create Build Directory
        run: |
          mkdir "%RUNNER_TEMP%\build"
      - name: Prepare Driver Files
        run: |
          mkdir "%SOURCE_DIR%\drivers\windows"
          copy "driver\windows\*" "%SOURCE_DIR%\drivers\windows\" /Y
      - name: Update Translations (lupdate + lrelease)
        working-directory: ${{ runner.temp }}\build
        run: |
          set PATH=C:\Qt6\bin;C:\mingw64\bin;%PATH%
          if not exist "C:\Qt6\bin\lupdate.exe" ( echo lupdate not found & exit /b 1 )
          C:\Qt6\bin\lupdate.exe "%SOURCE_DIR%\openterfaceQT.pro"
          C:\Qt6\bin\lrelease.exe "%SOURCE_DIR%\openterfaceQT.pro"
      - name: Build Portable Executable with CMake
        working-directory: ${{ runner.temp }}\build
        shell: cmd
        run: |
          set PATH=C:\Qt6\bin;C:\mingw64\bin;%PATH%
          
          cmake -G "Ninja" ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_TOOLCHAIN_FILE="D:/vcpkg/scripts/buildsystems/vcpkg.cmake" ^
            -DVCPKG_TARGET_TRIPLET="x64-mingw-static" ^
            -DCMAKE_PREFIX_PATH="C:/Qt6" ^
            -DOPENTERFACE_BUILD_STATIC=ON ^
            -DCMAKE_C_COMPILER="C:/mingw64/bin/gcc.exe" ^
            -DCMAKE_CXX_COMPILER="C:/mingw64/bin/g++.exe" ^
            -DCMAKE_RC_COMPILER="C:/mingw64/bin/windres.exe" ^
            "%SOURCE_DIR%"
          
          if errorlevel 1 (
            echo CMake configuration failed
            exit /b 1
          )
          
          cmake --build . --config Release -- -j2
          
          if errorlevel 1 (
            echo CMake build failed
            exit /b 1
          )
          
          for /f "delims=" %%F in ('dir /s /b openterfaceQT.exe 2^>nul') do set "EXE=%%F"
          
          if not defined EXE (
            echo Build failed: openterfaceQT.exe not found
            dir /s /b .
            exit /b 1
          )
          
          echo Found executable: %EXE%
          
          echo Checking for DLL dependencies...
          C:\mingw64\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll" >nul
          if not errorlevel 1 (
            echo ERROR: DLL dependencies detected!
            C:\mingw64\bin\objdump.exe -p "%EXE%" | findstr /i "\.dll"
            exit /b 1
          )
          
          echo OK: No DLL dependencies - fully static.
          
          C:\mingw64\bin\strip.exe -s "%EXE%"
          
          if not exist package mkdir package
          copy "%EXE%" package\openterfaceQT-portable.exe
          
          if errorlevel 1 (
            echo Failed to copy executable to package directory
            exit /b 1
          )
          
          echo Build completed successfully
          dir package
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT }}
          path: ${{ runner.temp }}\build\package\openterfaceQT-portable.exe
          if-no-files-found: error